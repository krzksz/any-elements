{"version":3,"file":"anyElements.mjs","sources":["../src/constants.ts","../src/component.ts","../src/registry.ts","../src/anyElements.ts"],"sourcesContent":["/**\n * Name of the node's property component will be assigned to.\n */\nexport const PROPERTY_NAME = \"$any\";\n","import { PROPERTY_NAME } from \"./constants\";\n\ninterface ComponentArguments {\n  node: Element;\n  name: string;\n  options?: {};\n}\n\ninterface AttachedListener {\n  eventName: string;\n  node: Element;\n  listener: EventListenerOrEventListenerObject;\n  options: boolean | EventListenerOptions;\n}\n\nlet eventObjectSupported = false;\n\ntry {\n  window.addEventListener(\n    \"test\",\n    null,\n    Object.defineProperty({}, \"capture\", {\n      get() {\n        eventObjectSupported = true;\n      },\n    })\n  );\n} catch (err) {}\n\nexport default class Component {\n  /**\n   * Component's name.\n   */\n  public name: string;\n  /**\n   * DOM node attached with the component.\n   */\n  public node: Element;\n  /**\n   * Component's options.\n   */\n  public options: {} = {};\n  /**\n   * Mutation observer assigned to the component.\n   */\n  protected observer: MutationObserver;\n  /**\n   * Array of event listeners attached to the component.\n   */\n  protected listeners: AttachedListener[] = [];\n\n  public constructor({ node, name, options }: ComponentArguments) {\n    this.node = node;\n    node[PROPERTY_NAME] = this;\n    this.name = name;\n    Object.assign(this.options, options);\n  }\n\n  /**\n   * Returns an array of attributes that should be observed for changes.\n   */\n  public observedAttributes(): string[] | void {}\n\n  /**\n   * Method invoked when component's node is added to the DOM tree.\n   */\n  public connected(): void {}\n\n  /**\n   * Method invoked when component's node is removed from the DOM tree.\n   */\n  public disconnected(): void {}\n\n  public attachEvent(\n    eventName: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  );\n  public attachEvent(\n    eventName: string,\n    delegate: Element,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  );\n  public attachEvent(\n    eventName: string,\n    listenerOrDelegate: any,\n    listener: any,\n    options?: boolean | AddEventListenerOptions\n  ): void {\n    let node = listenerOrDelegate;\n    if (!(listenerOrDelegate instanceof Node)) {\n      node = this.node;\n      options = listener;\n      listener = listenerOrDelegate;\n    }\n    options = eventObjectSupported\n      ? options\n      : (options as EventListenerOptions).capture;\n\n    node.addEventListener(eventName, listener, options);\n    this.listeners.push({ eventName, node, listener, options });\n  }\n}\n","import { PROPERTY_NAME } from \"./constants\";\nimport Component from \"./component\";\n\ninterface ComponentRegistry {\n  [componentName: string]: {\n    _constructor: Component | PromiseLike<Component>;\n    _options: {\n      selector: string;\n    };\n  };\n}\n\nconst registry: ComponentRegistry = {};\nconst promises = {};\n\nconst rootNode = document.body;\n\nconst forEach = Array.prototype.forEach;\n\n/**\n * Connects given DOM node with provided component.\n * @param node DOM node that should be tied with the component.\n * @param name Name of the component.\n * @param options Options object for the component.\n * @param constructor Component class or a function returning a promise that resolves to it.\n */\nconst connect = (\n  node: Element,\n  name: string,\n  options: {},\n  constructor: any\n) => {\n  if (node[PROPERTY_NAME]) {\n    return;\n  }\n  // If component was not provided, it means that this is a function.\n  if (!(constructor.prototype instanceof Component)) {\n    constructor = constructor();\n  }\n\n  Promise.resolve(constructor).then(Constructor => {\n    const instance = new Constructor({ node, name, options });\n\n    const attributeFilter = instance.observedAttributes();\n    if (attributeFilter) {\n      const observer = new MutationObserver(mutationsList => {\n        forEach.call(mutationsList, ({ attributeName, oldValue, target }) => {\n          instance.attributeChanged(\n            attributeName,\n            oldValue,\n            (target as Element).getAttribute(attributeName)\n          );\n        });\n      });\n\n      instance.observer = observer;\n\n      observer.observe(node, {\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter,\n      });\n    }\n\n    instance.connected();\n  });\n};\n\n/**\n * Cleans-up the component for a given node.\n * @param node Node that has been removed from the DOM.\n */\nconst disconnect = (node: Element) => {\n  const instance = node[PROPERTY_NAME];\n\n  if (!instance) {\n    return;\n  }\n\n  const observer = instance.observer;\n  if (observer) {\n    observer.disconnect();\n  }\n\n  instance.disconnected();\n\n  forEach.call(instance.listeners, ({ eventName, node, listener, options }) =>\n    node.removeEventListener(eventName, listener, options)\n  );\n  instance.listeners = [];\n\n  delete instance.node[PROPERTY_NAME];\n  delete instance.node;\n};\n\n/**\n * Initializes components for given root node and its descendants.\n * @param rootNode Root element of the tree that was added to the DOM.\n * @param nameFilter Which components should be initialized, will be all defined if not provided.\n */\nconst connectAll = (rootNode: Element, nameFilter?: string) => {\n  // 1 is Node.ELEMENT_NODE\n  if (rootNode.nodeType !== 1) {\n    return;\n  }\n\n  const names = nameFilter ? registry[nameFilter] : Object.keys(registry);\n\n  forEach.call(names, (name: string) => {\n    const element = registry[name];\n    const selector = element._options.selector;\n\n    if (rootNode.matches(selector)) {\n      connect(rootNode, name, element._options, element._constructor);\n    }\n\n    forEach.call(rootNode.querySelectorAll(selector), (node: Element) =>\n      connect(node, name, element._options, element._constructor)\n    );\n  });\n};\n\n/**\n * Disconnects all components for given root node and its descendants.\n * @param rootNode Root node which was removed from the DOM.\n */\nconst disconnectAll = (rootNode: Element) => {\n  // 1 is Node.ELEMENT_NODE\n  if (rootNode.nodeType !== 1) {\n    return;\n  }\n\n  disconnect(rootNode);\n\n  forEach.call(rootNode.querySelectorAll(`*`), disconnect);\n};\n\nexport default class AnyElementsRegistry {\n  public constructor() {\n    new MutationObserver(mutationsList => {\n      forEach.call(mutationsList, mutation => {\n        forEach.call(mutation.removedNodes, disconnectAll);\n        forEach.call(mutation.addedNodes, connectAll);\n      });\n    }).observe(rootNode, {\n      childList: true,\n      subtree: true,\n    });\n\n    connectAll(rootNode);\n  }\n\n  /**\n   * Registers component with a given name and options.\n   * @param name Name of the component.\n   * @param constructor Constructor or a function that returns a promise resolving with a constructor.\n   * @param options Component's options.\n   */\n  public define(\n    name: string,\n    constructor: Component | PromiseLike<Component>,\n    options: { selector?: string } = {}\n  ): void {\n    if (typeof name !== \"string\" || !name.match(/^[a-z][^A-Z]*\\-[^A-Z]*$/)) {\n      throw new Error(`\"${name}\" is not a valid component name`);\n    }\n\n    registry[name] = {\n      _constructor: constructor,\n      _options: {\n        selector: options.selector || name,\n      },\n    };\n\n    connectAll(rootNode, name);\n\n    forEach.call(promises[name] || [], resolve => resolve());\n  }\n\n  /**\n   * Removes component with a given name from the registry.\n   * @param name Component's name.\n   */\n  public undefine(name: string) {\n    delete registry[name];\n  }\n\n  /**\n   * Returns component's constructor or a function that returns a promise resolving to it for a given name.\n   * @param name Component's name.\n   */\n  public get(name: string): Component | PromiseLike<Component> {\n    return registry[name] ? registry[name]._constructor : undefined;\n  }\n\n  /**\n   * Returns a promise that is going to be resolved when the component with given name gets defined.\n   * @param name Component's name.\n   */\n  public whenDefined(name: string): Promise<void> {\n    const promise = new Promise(resolve => {\n      if (this.get(name)) {\n        return resolve();\n      }\n      promises[name] = promises[name] || [];\n      promises[name].push(resolve);\n    }) as Promise<void>;\n\n    return promise;\n  }\n}\n","import AnyElementsRegistry from \"./registry\";\nimport Component from \"./component\";\n\nconst Registry = new AnyElementsRegistry();\n\nexport { Component, Registry };\n"],"names":["eventObjectSupported","window","addEventListener","Object","defineProperty","get","err","Component","constructor","ref","node","this","name","assign","options","observedAttributes","connected","disconnected","attachEvent","eventName","listenerOrDelegate","listener","Node","capture","listeners","push","const","registry","promises","rootNode","document","body","forEach","Array","prototype","connect","Promise","resolve","then","Constructor","instance","attributeFilter","observer","MutationObserver","mutationsList","call","attributeChanged","attributeName","getAttribute","observe","attributes","attributeOldValue","disconnect","removeEventListener","connectAll","nameFilter","nodeType","names","keys","element","selector","_options","matches","_constructor","querySelectorAll","disconnectAll","AnyElementsRegistry","mutation","removedNodes","addedNodes","define","match","Error","undefine","undefined","whenDefined","Registry"],"mappings":"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"}