{"version":3,"file":"anyElements.umd.js","sources":["../src/registry.ts","../src/anyElements.ts"],"sourcesContent":["import { HTMLAnyElement } from \"./interface\";\n\ntype AnyElementFunction = () => HTMLAnyElement;\ntype AnyElementPromise = () => Promise<HTMLAnyElement>;\n\nconst registry = {};\nconst promises = {};\nconst callOptional = callable => callable && callable();\nconst isFunction = variable => typeof variable === \"function\";\n\nconst connect = (\n  element: HTMLAnyElement,\n  name: string,\n  constructor: HTMLAnyElement | AnyElementFunction | AnyElementPromise\n) => {\n  if (element.$any) {\n    return;\n  }\n\n  element.$any = { name, observer: null };\n\n  const objectOrPromise: HTMLAnyElement | AnyElementPromise = isFunction(\n    constructor\n  )\n    ? (constructor as AnyElementFunction)()\n    : (constructor as HTMLAnyElement);\n\n  Promise.resolve(objectOrPromise).then(constructorObject => {\n    for (let key in constructorObject) {\n      const value = constructorObject[key];\n      element[key] = isFunction(value) ? value.bind(element) : value;\n    }\n\n    const attributeFilter = callOptional(element.observedAttributes);\n    if (attributeFilter) {\n      const observer = new MutationObserver(mutationsList => {\n        mutationsList.forEach(function(mutation) {\n          const attributeName = mutation.attributeName;\n          element.attributeChangedCallback(\n            attributeName,\n            mutation.oldValue,\n            (mutation.target as HTMLElement).getAttribute(attributeName)\n          );\n        });\n      });\n\n      observer.observe(element as Node, {\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter,\n      });\n      element.$any.observer = observer;\n    }\n\n    callOptional(element.connectedCallback);\n  });\n};\n\nconst disconnect = element => {\n  if (!element.$any) {\n    return;\n  }\n\n  const observer = element.$any.observer;\n  if (observer) {\n    observer.disconnect();\n  }\n\n  callOptional(element.disconnectedCallback);\n\n  delete element.$any;\n};\n\nconst connectAll = parent => {\n  // 1 is Node.ELEMENT_NODE\n  if (parent.nodeType !== 1) {\n    return;\n  }\n\n  for (let name in registry) {\n    const { _selector, _constructor } = registry[name];\n\n    if (parent.matches(_selector)) {\n      connect(\n        parent,\n        name,\n        _constructor\n      );\n    }\n\n    const elements = parent.querySelectorAll(_selector);\n\n    for (let i = 0; i < elements.length; i++) {\n      connect(\n        elements[i],\n        name,\n        _constructor\n      );\n    }\n  }\n};\n\nconst disconnectAll = parentNode => {\n  // 1 is Node.ELEMENT_NODE\n  if (parentNode.nodeType !== 1) {\n    return;\n  }\n\n  disconnect(parentNode);\n\n  const elements = parentNode.querySelectorAll(`*`);\n  for (let i = 0; i < elements.length; i++) {\n    disconnect(elements[i]);\n  }\n};\n\nexport default class AnyElementRegistry {\n  public constructor() {\n    const rootNode = document.body;\n\n    new MutationObserver(mutationsList => {\n      mutationsList.forEach(mutation => {\n        const disconnected = mutation.removedNodes;\n        for (let i = 0; i < disconnected.length; i++) {\n          disconnectAll(disconnected[i]);\n        }\n\n        const connected = mutation.addedNodes;\n        for (let i = 0; i < connected.length; i++) {\n          connectAll(connected[i]);\n        }\n      });\n    }).observe(rootNode, {\n      childList: true,\n      subtree: true,\n    });\n\n    connectAll(rootNode);\n  }\n\n  public define(\n    name: string,\n    constructor: object,\n    options: { selector?: string } = {}\n  ): void {\n    if (typeof name !== \"string\" || !name.match(/^[a-z][^A-Z]*\\-[^A-Z]*$/)) {\n      throw new DOMException(`\"${name}\" is not a valid element name`);\n    }\n    if (this.get(name)) {\n      throw new DOMException(`'${name}' has already been declared`);\n    }\n\n    registry[name] = {\n      _constructor: constructor,\n      _selector: options.selector || name,\n    };\n\n    if (promises[name]) {\n      promises[name].forEach(resolve => resolve());\n    }\n  }\n\n  public undefine(name: string) {\n    delete registry[name];\n  }\n\n  public get(name: string): object | undefined {\n    const defined = registry[name] || {};\n\n    return defined._constructor;\n  }\n\n  public whenDefined(name: string): Promise<void> {\n    const promise = new Promise(resolve => {\n      if (this.get(name)) {\n        resolve();\n      } else {\n        if (!promises[name]) {\n          promises[name] = [];\n        }\n        promises[name].push(resolve);\n      }\n    }) as Promise<void>;\n\n    return promise;\n  }\n}\n","import AnyElementRegistry from \"./registry\";\n\nexport default new AnyElementRegistry();\n"],"names":["const","registry","promises","callOptional","callable","isFunction","variable","connect","element","name","constructor","$any","observer","objectOrPromise","Promise","resolve","then","constructorObject","let","key","value","bind","attributeFilter","observedAttributes","MutationObserver","mutationsList","forEach","mutation","attributeName","attributeChangedCallback","oldValue","target","getAttribute","observe","attributes","attributeOldValue","connectedCallback","disconnect","disconnectedCallback","connectAll","parent","nodeType","matches","_selector","_constructor","elements","querySelectorAll","i","length","disconnectAll","parentNode","AnyElementRegistry","rootNode","document","body","disconnected","removedNodes","connected","addedNodes","define","options","match","DOMException","this","get","selector","undefine","whenDefined","push"],"mappings":"0KAKAA,IAAMC,EAAW,GACXC,EAAW,GACXC,WAAeC,UAAYA,GAAYA,KACvCC,WAAaC,SAAgC,mBAAbA,GAEhCC,WACJC,EACAC,EACAC,OAEIF,EAAQG,MAIZH,EAAQG,KAAO,MAAEF,EAAMG,SAAU,UAE3BC,EAAsDR,EAC1DK,GAEGA,IACAA,EAELI,QAAQC,QAAQF,GAAiBG,cAAKC,OAC/BC,IAAIC,KAAOF,EAAmB,KAC3BG,EAAQH,EAAkBE,GAChCX,EAAQW,GAAOd,EAAWe,GAASA,EAAMC,KAAKb,GAAWY,MAGrDE,EAAkBnB,EAAaK,EAAQe,uBACzCD,EAAiB,KACbV,EAAW,IAAIY,0BAAiBC,GACpCA,EAAcC,QAAQ,SAASC,OACvBC,EAAgBD,EAASC,cAC/BpB,EAAQqB,yBACND,EACAD,EAASG,SACRH,EAASI,OAAuBC,aAAaJ,QAKpDhB,EAASqB,QAAQzB,EAAiB,CAChC0B,YAAY,EACZC,mBAAmB,kBACnBb,IAEFd,EAAQG,KAAKC,SAAWA,EAG1BT,EAAaK,EAAQ4B,uBAInBC,WAAa7B,MACZA,EAAQG,UAIPC,EAAWJ,EAAQG,KAAKC,SAC1BA,GACFA,EAASyB,aAGXlC,EAAaK,EAAQ8B,6BAEd9B,EAAQG,OAGX4B,WAAaC,MAEO,IAApBA,EAAOC,aAINvB,IAAIT,KAAQR,EAAU,OACWA,EAASQ,eAEzC+B,EAAOE,QAAQC,IACjBpC,EACEiC,EACA/B,EACAmC,WAIEC,EAAWL,EAAOM,iBAAiBH,GAEhCI,EAAI,EAAGA,EAAIF,EAASG,OAAQD,IACnCxC,EACEsC,EAASE,GACTtC,EACAmC,KAMFK,WAAgBC,MAEQ,IAAxBA,EAAWT,UAIfJ,EAAWa,WAELL,EAAWK,EAAWJ,sBACnBC,EAAI,EAAGA,EAAIF,EAASG,OAAQD,IACnCV,EAAWQ,EAASE,MAIHI,EACnBzC,eACQ0C,EAAWC,SAASC,SAEtB9B,0BAAiBC,GACnBA,EAAcC,iBAAQC,WACd4B,EAAe5B,EAAS6B,aACrBT,EAAI,EAAGA,EAAIQ,EAAaP,OAAQD,IACvCE,EAAcM,EAAaR,YAGvBU,EAAY9B,EAAS+B,WAClBX,EAAI,EAAGA,EAAIU,EAAUT,OAAQD,IACpCR,EAAWkB,EAAUV,QAGxBd,QAAQmB,EAAU,YACR,WACF,IAGXb,EAAWa,WAGNO,YAAAA,gBACLlD,EACAC,EACAkD,qBAAiC,IAEb,iBAATnD,IAAsBA,EAAKoD,MAAM,iCACpC,IAAIC,iBAAiBrD,sCAEzBsD,KAAKC,IAAIvD,SACL,IAAIqD,iBAAiBrD,iCAG7BR,EAASQ,GAAQ,GACDC,EACdiC,EAAWiB,EAAQK,UAAYxD,GAG7BP,EAASO,IACXP,EAASO,GAAMiB,iBAAQX,UAAWA,OAI/BmD,YAAAA,kBAASzD,UACPR,EAASQ,IAGXuD,YAAAA,aAAIvD,UACOR,EAASQ,IAAS,IAEnBmC,GAGVuB,YAAAA,qBAAY1D,qBACD,IAAIK,iBAAQC,GACtBgD,EAAKC,IAAIvD,QAGNP,EAASO,KACZP,EAASO,GAAQ,MAEVA,GAAM2D,KAAKrD,OClLb,IAAIoC"}